 /*
  * Copyright 2012 Michael Bischoff
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */

package de.jpaw.persistence.dsl.scoping;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
//import org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider;
//import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.ImportNormalizer;
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider;

import de.jpaw.bonaparte.dsl.bonScript.ClassDefinition;
import de.jpaw.bonaparte.dsl.bonScript.PackageDefinition;
import de.jpaw.bonaparte.dsl.generator.XUtil;
import de.jpaw.persistence.dsl.bDDL.EntityDefinition;
import de.jpaw.persistence.dsl.bDDL.ListOfColumns;
import de.jpaw.persistence.dsl.bDDL.SingleColumn;
import de.jpaw.persistence.dsl.generator.YUtil;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
/* The following code is based on guidelines found on the net, given by Jan Kohnlein (http://www.eclipse.org/forums/index.php/t/359674/)
 * Quote: "add your imports as an ImportNormalizer.
 * The method createImportedNamespaceResolver(String, boolean) helps you create such
 * an object. The XtendImportedNamespaceScopeProvider does something similar."
 * ...
 * "Don't forget to bind your subclass of the ImportedNamespaceAwareScopeProviderin the runtime module of your language."
 *  */
public class BDDLScopeProvider extends ImportedNamespaceAwareLocalScopeProvider { // was autogenerated: AbstractDeclarativeScopeProvider {
    
    private void recursivelyAddColumnsOfClassAndParents(List<ImportNormalizer> preliminaryResult,
            ClassDefinition cl, boolean ignoreCase) {
        while (cl != null) {
            //System.out.println("DEBUG:   POJO is " + cl.getName());
            if (cl.eContainer() == null)  // occurs if a previously referenced import is deleted... 
                return;
            PackageDefinition bonScriptPd = (PackageDefinition)cl.eContainer();  // ATTN: the bonScript one!
            // alternative way to get the namespace could be to run it through a new DefaultDeclarativeQualifiedNameProvider(); 
            String qualifiedImportNamespace = bonScriptPd.getName() + "." + cl.getName() + ".*";
            //System.out.println("DEBUG:   adding " + qualifiedImportNamespace + " to imports...");
            preliminaryResult.add(createImportedNamespaceResolver(qualifiedImportNamespace, ignoreCase));
            cl = XUtil.getParent(cl);
        }
    }
    
    @Override
    protected
    List<ImportNormalizer> internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {
        List<ImportNormalizer> preliminaryResult;
        if ((context instanceof ListOfColumns || context instanceof SingleColumn) && context.eContainer() != null) {
            // the only valid reference in a list of columns is a column of the entity referenced.
            preliminaryResult = new ArrayList<ImportNormalizer>(10);
            //ListOfColumns loc = (ListOfColumns)context;
            EntityDefinition entity = (EntityDefinition)context.eContainer();
            // System.out.println("DEBUG: Resolver invoked for ListOfColumns inside " + entity.getName());
            recursivelyAddColumnsOfClassAndParents(preliminaryResult, entity.getPojoType(), ignoreCase);
            // also add the fields of the entity category class (& parents)
            if (entity.getTableCategory() != null)
                recursivelyAddColumnsOfClassAndParents(preliminaryResult, entity.getTableCategory().getTrackingColumns(), ignoreCase);
            // also add the fields in a potential tenant discriminator class
            if (YUtil.getInheritanceRoot(entity).getTenantClass() != null)
                recursivelyAddColumnsOfClassAndParents(preliminaryResult, YUtil.getInheritanceRoot(entity).getTenantClass(), ignoreCase);
        } else {
            preliminaryResult = super.internalGetImportedNamespaceResolvers(context, ignoreCase);
        }
        return preliminaryResult;
    }
}
